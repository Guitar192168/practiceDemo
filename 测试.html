<!doctype html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport"          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title></head><body><script>    // var x = 1;    // function bar(){    //     this.x = 2;    //     return x;    // }    // var foo = new bar()    // alert(foo.x)    // var obj = {    //     name: '123',    //     __proto__: {    //         laseName: 'ni'    //     }    // }    //    // Object.prototype.abc = '123'    //    // for (var prop in obj) {    //     if (!obj.hasOwnProperty(prop)) {    //         console.log(obj.prop)    //     }    // }    // var a = 1    //    // function test() {    //     a = 10    //     console.log(a)    //     var a = 0    //     console.log(this.a)    //     console.log(a)    // }    //    // test()    // //    这里的this指向window    //    // // ------------------------------    //    // var a = 1    //    // function test() {    //     a = 10    //     console.log(a)    //     var a = 0    //     console.log(this.a)    //     console.log(a)    // }    //    // //这里的this指向该函数    // var te = new test()    // a  = 100    // function demo(e){    //     function e(){}    //     arguments[0] = 2    //     console.log(e)    //     if(a){    //         var b = 123    //         function c(){    //    //         }    //     }    //    //     var c;    //     a = 10    //     var a;    //     console.log(b)    //     f = 123    //     console.log(c)    //     console.log(a)    // }    //    // var a;    // demo(1);    // console.log(a)    // console.log(f)    // var name = 'a'    // var obj = {    //     name: 'b',    //     child: {    //         name: 'c',    //         fn: function () {    //             debugger    //             return this.name    //         }    //     }    // }    //    // console.log(obj.child.fn())    // var ff = obj.child.fn    // console.log(ff())    //不用递归的去产生一个斐波那契数列    // var a = 4    // var a1 = 1    // var a2 = 1    // for (let i = 1; i <= a - 2; i++) {    //     a2 = a1 + a2    //     a1 = a2 - a1    //     if (i === a - 2) {    //         console.log(a2)    //     }    // }    //好人哥的版本，运用上ES6    // 思想还是将第二个值赋值给第一个，然后第一个和第二个的值赋值给第二个    // function fb(m) {    //     if (m === 1 || m === 2) {    //         return 1    //     }    //     let a = 1,    //         b = 1    //     for (let i = 0; i < m - 2; i++) {    //         [a, b] = [b, a + b]    //     }    //     return b    // }    //    // //1 1 2 3 5    // console.log(fb(5))    //求差集 ，交集均可用    //has是Set的方法    // Set.prototype.has()    // let arr1 = [1, 2, 3, 4, 5]    // let arr2 = [4, 5, 6, 7, 8]    //    // new Set(arr1)    // arr2 = new Set(arr2)    //    // let result = arr1.filter(item => !arr2.has(item))    // console.log(result)    // function fn(a) {    //     console.log(a);    //     var a = 123;    //     console.log(a);    //    //     function a() {    //     }    //    //     console.log(a);    //     var b = function () {    //     }    //     console.log(b);    //    //     function d() {    //     }    // }    //    // fn(1);    function a(a) {        var a = 234;        var a = function () {        }        a();    }    var a = 123;</script></body></html>